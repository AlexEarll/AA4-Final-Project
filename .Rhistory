}
GetMovieInfo("Book of Eli")
GetMovieInfo <- function(movie.name) {
movie.url <- paste0(base, "search/", movie.name, ".json")
print(movie.url)
response <- GET(paste0(base, "/search/", movie.name, ".json"))
result <- fromJSON(content(respose, "text"))
print(result)
}
GetMovieInfo("Book of Eli")
GetMovieInfo <- function(movie.name) {
movie.url <- paste0(base, "search/", movie.name, ".json")
print(movie.url)
response <- GET(movie.url, query = query.params)
result <- fromJSON(content(respose, "text"))
print(result)
}
GetMovieInfo("Book of Eli")
---
title: "Class demo"
author: "Alex Earll"
date: "February 2, 2017"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## R Markdown
This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.
When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:
```{r cars}
summary(cars)
```
## Including Plots
You can also embed plots, for example:
```{r pressure, echo=FALSE}
plot(pressure)
```
Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
---
title: "Hidden Figures Review"
author: "Alex Earll"
date: "February 2, 2017"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
GetMovieInfo <- function(movie.name) {
movie.url <- paste0(base, "search/", movie.name, ".json")
print(movie.url)
response <- GET(movie.url, query = query.params)
result <- fromJSON(content(respose, "text"))
print(result)
}
```{r}
movie <- "Hidden Figures"
movie.info <- GetMovieInfo(movie)
```
---
title: "Hidden Figures Review"
author: "Alex Earll"
date: "February 2, 2017"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
GetMovieInfo <- function(movie.name) {
movie.url <- paste0(base, "search/", movie.name, ".json")
print(movie.url)
response <- GET(movie.url, query = query.params)
result <- fromJSON(content(respose, "text"))
print(result)
}
```{r}
movie <- "Hidden Figures"
movie.info <- GetMovieInfo(movie)
```
knitr::opts_chunk$set(echo = TRUE)
GetMovieInfo <- function(movie.name) {
movie.url <- paste0(base, "search/", movie.name, ".json")
print(movie.url)
response <- GET(movie.url, query = query.params)
result <- fromJSON(content(respose, "text"))
print(result)
}
movie <- "Hidden Figures"
movie.info <- GetMovieInfo(movie)
library("httr")
library("jsonlite")
# Use `source()` to load your API key variable.
# Make sure you've set your working directory!
my.api.key <- "c03a94bb2b39436a9373b57148b84a22"
query.params <- list(access_token = my.apikey)
# Exercise 1: ggplot2 basics
# Install and load `ggplot2`
# You will also want to load `dplyr`
# install.packages("ggplot2")  # once per machine
library("ggplot2")  # load the package
library("dplyr")
# For this exercise you'll be working with the `diamonds` data set included in the ggplot2 library
# Use `?diamonds` to get more information about this data set (including the column descriptions
# Also check the _column names_ and the _number of rows_ in the data set
View(diamonds)
# ?diamonds
# This data set has a lot of rows. To make things a bit more readable,
# use dplyr's `sample_n()` function to get a random 1000 rows from the data set
# Store this sample in a variable `diamonds.sample`
diamonds.sample <- sample_n(diamonds, 1000)
# Start by making a new `ggplot` with the `diamonds.sample` as the data (no geometry yet)
# What do you see?
ggplot(data = diamonds.sample)
# Draw a scatter plot (with point geometry) with for the `diamonds.sample` set,
# with the `carat` mapped to the x-position and `price` mapped to the y-position.
ggplot(data = diamonds.sample) +
geom_point(mapping = aes(x = carat, y = price))
# Draw the same plot as above, but color each of the points based on their clarity.
ggplot(data = diamonds.sample) +
geom_point(mapping = aes(x = carat, y = price, color = clarity))
# Draw the same plot as above, but for the entire `diamonds` data set. Note this may take
# a few seconds to generate.
ggplot(data = diamonds) +
geom_point(mapping = aes(x = carat, y = price, color = clarity))
# Draw another scatter plot for `diamonds.sample` of price (y) by carat (x),
# but with all of the dots colored "blue".
# Hint: you'll need to set the color channel, not map a value to it!
ggplot(data = diamonds.sample) +
geom_point(mapping = aes(x = carat, y = price), color = "blue")
# Draw a scatter plot for `diamonds.sample` of `price` by `carat`, where each
# point has an aesthetic _shape_ based on the diamond's `cut`.
ggplot(data = diamonds.sample) +
geom_point(mapping = aes(x = carat, y = price, color = clarity, shape =  cut))
# Draw a scatter plot for `diamonds.sample` of *`cut`* by `carat`, where each
# point has an aesthetic _size_ based on the diamond's *`price`*
ggplot(data = diamonds.sample) +
geom_point(mapping = aes(x = carat, y = price, size =  price))
# Try coloring the above plot based on the diamond's price!
ggplot(data = diamonds.sample) +
geom_point(mapping = aes(x = carat, y = price, size =  price, color = price))
# Draw a line plot (with line geometry) for `diamonds.sample`. The x-position should be mapped to
# carat, y-position to price, and color to carat.
ggplot(data = diamonds.sample) +
geom_line(mapping = aes(x = carat, y = price, color = carat))
# That's kind of messy. Try using `smooth` geometry instead.
ggplot(data = diamonds.sample) +
geom_smooth(mapping = aes(x = carat, y = price, color = carat))
# Draw a plot with bar geometry (a bar chart), mapping the diamond's `cut` to the x-axis
ggplot(data = diamonds.sample) +
geom_bar(mapping = aes(x = cut))
# Add an aesthetic property that will _fill_ each bar geometry based on the `clarity` of the diamonds
# What kind of chart do you get?
ggplot(data = diamonds.sample) +
geom_bar(mapping = aes(x = cut, fill = clarity))
# Draw a histogram of diamond prices.
# Try mapping each bar based on clarity as well!
ggplot(data = diamonds.sample) +
geom_histogram(mapping = aes(x = price, fill = clarity))
# (For a more traditional "bell-curve", make a histogram of diamond `depths`)
ggplot(data = diamonds.sample) +
geom_histogram(mapping = aes(x = depth, fill = clarity))
# Draw a plot of the `diamonds.sample` data (price by carat), with both points for each
# diamond AND smoothed lines for each cut (hint: in a separate color)
# Making the points have some `alpha` transparency will make the plot look nicer
# multiple geoms (point & smooth)
ggplot(data = diamonds.sample) +
geom_point(mapping = aes(x = carat, y = price, color  = carat)) +
geom_smooth(mapping = aes(x = carat, y = price, color = carat))
## Bonus
# Draw a bar chart of average diamond prices by clarity, and include "error bars" marking
# the standard error of each measurement.
#
# You can calculate standard error as the _standard deviation_ divided by the square root
# of the number of measurements (prices)
# Start by creating a data frame `diamond.summary` that includes summarized data for each clarity group.
# Your summary data shuld include the mean price and the standard error of the price.
# Then draw the plot. The error bars should stretch from the mean-error to the mean+error.
# Exercise 2: More ggplot2 Grammar
# Install and load `ggplot2`
# install.packages("ggplot2") # if needed
library("ggplot2")  # load the package
library("dplyr")
# For this exercise you will again be working with the `diamonds` data set.
# Use `?diamonds` to review details about this data set
?diamonds
View(head(diamonds))
## Statistical Transformations
# Draw a bar chart of the diamonds data, organized by cut
# The height of each bar is based on the "count" (number) of diamonds with that cut
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut))
# Use the `stat_count` to apply the statistical transformation "count" to the diamonds
# by cut. You do not need a separate geometry layer!
ggplot(data = diamonds) +
stat_count(mapping = aes(x = cut))
# Use the `stat_summary` function to draw a chart with a summary layer.
# Map the x-position to diamond `cut`, and the y-position to diamond `depth`
# Bonus: use `min` as the function ymin, `max` as the function ymax, and `median` as the function y
ggplot(data = diamonds) +
stat_summary(mapping = aes(x = cut, y = depth))
## Position Adjustments
# Draw a bar chart of diamond data organized by cut, with each bar filled by clarity.
# You should see a _stacked_ bar chart.
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")
# Draw the same chart again, but with each element positioned to "fill" the y axis
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill") +
coord_flip()
# Draw the same chart again, but with each element positioned to "dodge" each other
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")
# Draw a plot with point geometry with the x-position mapped to `cut` and the y-position mapped to `clarity`
# This creates a "grid" grouping the points
ggplot(data = diamonds) +
geom_point(mapping = aes(x = cut, y = clarity)) +
facet_wrap(~cut)
# Use the "jitter" position adjustment to keep the points from all overlapping!
# (This works a little better with a sample of diamond data, such as from the previous exercise).
## Scales
# Draw a "boxplot" (with `geom_boxplot()`) for the diamond's price (y) by color (x)
# This has a lot of outliers, making it harder to read. To fix this, draw the same plot but
# with a _logarithmic_ scale for the y axis.
# For another version, draw the same plot but with `violin` geometry instead of `boxplot` geometry!
# How does the logarithmic scale change the data presentation?
# Another interesting plot: draw a plot of the diamonds price (y) by carat (x), using a heatmap of 2d bins
# (geom_bin2d)
# What happens when you make the x and y channels scale logarithmically?
# Draw a scatter plot for the diamonds  price (y) by carat (x). Color each point by the clarity
# (Remember, this will take a while. Use a sample of the diamonds for faster results)
# Change the color of the previous plot using a ColorBrewer scale of your choice. What looks nice?
## Coordinate Systems
# Draw a bar chart with x-position and fill color BOTH mapped to cut
# For best results, SET the `width` of the geometry to be 1 (fill plot, no space between)
# You can save this to a variable for easier modifications
# Draw the same chart, but with the coordinate system flipped
# Draw the same chart, but in a polar coordinate system. Now you have a Coxcomb chart!
## Facets
# Take the scatter plot of price by carat data (colored by clarity) and add _facets_ based on
# the diamond's `color`
## Saving Plots
# Use the `ggsave()` function to save one of your plots (the most recent one generated) to disk.
# Name the output file "my-plot.png".
# Make sure you've set the working directory!!
ggplot(data = diamonds) +
geom_point(mapping = aes(x = cut, y = clarity)) +
facet_wrap(~cut)
ggplot(data = diamonds) +
geom_point(mapping = aes(x = cut, y = clarity))
ggplot(data = diamonds) +
geom_point(mapping = aes(x = cut, y = clarity, position = "jitter"))
ggplot(data = diamonds) +
geom_point(mapping = aes(x = cut, y = clarity, position = "jitter"))
ggplot(data = diamonds) +
geom_point(mapping = aes(x = cut, y = clarity), position = "jitter")
ggplot(data = diamonds) +
geom_boxplot(mapping = aes(x = price, y = color))
ggplot(data = diamonds) +
geom_boxplot(mapping = aes(x = color, y = price))
setwd("~/Info 201/Assignments/AA4-Final-Project")
pokemon.data[x, ] <- temp.data
pokemon.data[x, ] <- temp.datapoke
pokemon.data[x, ] <- temp.dataprint(temp.data)
pokemon.data[x, ] <- temp.dataprint(names(poke.data))
pokemon.url = paste0(base.url, "pokemon/", 1)
print(pokemon.url)
response <- GET(pokemon.url)
body <- content(response, "text", encoding = "UTF-8")
temp.data <- fromJSON(body, flatten = TRUE)
temp.data$
library(shiny)
library(ggplot2)
library(dplyr)
library(httr)
library(jsonlite)
# Getting stats
# Start: http://pokeapi.co/api/v2/pokemon/?count=150&limit=150
# go into pokemon url
# Get stats from JSON
# hp, defence, attack, speed, type, color one for block colors
# Get moves and then query the moves api
# Check for key words or make super if statement tree
# Check power accuracy and type
# 'is damaging' and crit rate is in meta js
# Backend
# need something resembling an enum for damage types
# probably a damage type table represented by a table in excel
# Damage multipliers
# http://bulbapedia.bulbagarden.net/wiki/Type/Type_chart
# turn based loop
# print into a csv which we read out of after for data processing
###Setup###
pokemon.file <- read.csv("data/Pokemon.csv", stringsAsFactors=FALSE)
pokemon.data <- pokemon.file %>%
select(pokemon, species_id, base_experience, type_1, type_2, attack, defense, hp, special_attack, special_defense, ability_1, ability_2, ability_hidden, url_image, generation_id) %>%
filter(generation_id == 1)
View(pokemon.data)
base.url <- "http://pokeapi.co/api/v2/"
first.gen <- data.frame(nrow=150)
for(x in 2) {
pokemon.url = paste0(base.url, "pokemon/", 1)
print(pokemon.url)
response <- GET(pokemon.url)
body <- content(response, "text")
is.data.frame(body)
temp.data <- fromJSON(body)
print(value)
View(temp.data)
}
pokemon.url = paste0(base.url, "pokemon/", 1)
print(pokemon.url)
response <- GET(pokemon.url)
body <- content(response, "text", encoding = "UTF-8")
temp.data <- fromJSON(body, flatten = TRUE)
pokemon.data[x, 1] <- x
pokemon.data[x, 2] <- temp.data$name
pokemon.data[x, 3] <- temp.data$types$type
pokemon.data[x, 4] <- temp.data$
pokemon.data[x, 5] <- temp.data
pokemon.data[x, 6] <- temp.data
pokemon.data[x, 7] <- temp.data
pokemon.data[x, 8] <- temp.data
pokemon.data[x, 9] <- temp.datapoke
pokemon.data[x, 10] <- temp.data
pokemon.data[x, 11] <- temp.data
pokemon.data[x, 12] <- temp.data
pokemon.data[x, 13] <- temp.data
pokemon.data[x, 14] <- temp.data
pokemon.data[x, 15] <- temp.data
print(temp.data)
print(names(poke.data))
print(is.data.frame(poke.data))
print(is.data.frame(poke.data$moves))
poke.moves <- head(poke.data$moves)
View(poke.moves)
poke.moves <- flatten(poke.moves)
print(colnames(poke.moves))
poke.moves <- select(poke.moves, move.name)
poke.moves <- arrange(poke.moves, -move.rank)
View(poke.moves)
LoadImages <- function(name1, name2) {
image.urls <- c(paste0("https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/", name1, ".png"))
download.file(image.urls, destfile = paste0("img/", name1, ".png"), mode = "wb")
image.urls <- c(paste0("https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/", name2, ".png"))
download.file(image.urls, destfile = paste0("img/", name2, ".png"), mode = "wb")
}
###part 1###
#create shiny interface for selecting pokemon
###part 2###
#Create backend (sever) for math calculations and such to feed into the UI
###part 3###
#Create battle sequence
###part 4###
#Create output and summary of the battle
View(poke.moves)
pokemon.data[x, 3] <- temp.data$types$type.name[1]
print(temp.data$types$type.name[1])
print(temp.data$types$type.name[2])
pokemon.data[x, 5] <- temp.data$stats$stat[5]$name
pokemon.data[x, 5] <- temp.data$stats[1]$base_stat
pokemon.data[x, 5] <- temp.data$stats$base_stat
print(temp.data$stats$base_stat)
print(temp.data$stats$base_stat[1])
print(temp.data$stats$base_stat[5])
for(x in nums) {
pokemon.url = paste0(base.url, "pokemon/", x)
print(pokemon.url)
response <- GET(pokemon.url)
body <- content(response, "text", encoding = "UTF-8")
temp.data <- fromJSON(body, flatten = TRUE)
pokemon.data[x, 1] <- x
pokemon.data[x, 2] <- temp.data$name
pokemon.data[x, 3] <- temp.data$types$type.name[1]
pokemon.data[x, 4] <- temp.data$types$type.name[2]
pokemon.data[x, 5] <- temp.data$stats$base_stat[5]
pokemon.data[x, 6] <- temp.data$stats$base_stat[4]
pokemon.data[x, 7] <- temp.data$stats$base_stat[6]
pokemon.data[x, 8] <- temp.data$stats$base_stat[2]
pokemon.data[x, 9] <- temp.data$stats$base_stat[3]
pokemon.data[x, 10] <- temp.data$stats$base_stat[1]
}
base.url <- "http://pokeapi.co/api/v2/"
first.gen <- data.frame(nrow=151)
nums <- c(1:151)
for(x in nums) {
pokemon.url = paste0(base.url, "pokemon/", x)
print(pokemon.url)
response <- GET(pokemon.url)
body <- content(response, "text", encoding = "UTF-8")
temp.data <- fromJSON(body, flatten = TRUE)
first.gen[x, 1] <- x
first.gen[x, 2] <- temp.data$name
first.gen[x, 3] <- temp.data$types$type.name[1]
first.gen[x, 4] <- temp.data$types$type.name[2]
first.gen[x, 5] <- temp.data$stats$base_stat[5]
first.gen[x, 6] <- temp.data$stats$base_stat[4]
first.gen[x, 7] <- temp.data$stats$base_stat[6]
first.gen[x, 8] <- temp.data$stats$base_stat[2]
first.gen[x, 9] <- temp.data$stats$base_stat[3]
first.gen[x, 10] <- temp.data$stats$base_stat[1]
}
View(first.gen)
row.names(first.gen) <- c("id", "pokemon", "type_1", "type_2",
"attack", "defense", "hp", "special_attack", "speed")
col.names(first.gen) <- c("id", "pokemon", "type_1", "type_2",
"attack", "defense", "hp", "special_attack", "speed")
colnames(first.gen) <- c("id", "pokemon", "type_1", "type_2",
"attack", "defense", "hp", "special_attack", "speed")
View(first.gen)
colnames(first.gen) <- c("id", "pokemon", "type_1", "type_2",
"attack", "defense", "hp", "special_attack", "special_defense", "speed")
if(first.gen[1,151] != 151) {
for(x in nums) {
pokemon.url = paste0(base.url, "pokemon/", x)
print(pokemon.url)
response <- GET(pokemon.url)
body <- content(response, "text", encoding = "UTF-8")
temp.data <- fromJSON(body, flatten = TRUE)
first.gen[x, 1] <- x
first.gen[x, 2] <- temp.data$name
first.gen[x, 3] <- temp.data$types$type.name[1]
first.gen[x, 4] <- temp.data$types$type.name[2]
first.gen[x, 5] <- temp.data$stats$base_stat[5]
first.gen[x, 6] <- temp.data$stats$base_stat[4]
first.gen[x, 7] <- temp.data$stats$base_stat[6]
first.gen[x, 8] <- temp.data$stats$base_stat[2]
first.gen[x, 9] <- temp.data$stats$base_stat[3]
first.gen[x, 10] <- temp.data$stats$base_stat[1]
}
}
if(!file.exists(data/Pokemon)) {
for(x in nums) {
pokemon.url = paste0(base.url, "pokemon/", x)
print(pokemon.url)
response <- GET(pokemon.url)
body <- content(response, "text", encoding = "UTF-8")
temp.data <- fromJSON(body, flatten = TRUE)
first.gen[x, 1] <- x
first.gen[x, 2] <- temp.data$name
first.gen[x, 3] <- temp.data$types$type.name[1]
first.gen[x, 4] <- temp.data$types$type.name[2]
first.gen[x, 5] <- temp.data$stats$base_stat[5]
first.gen[x, 6] <- temp.data$stats$base_stat[4]
first.gen[x, 7] <- temp.data$stats$base_stat[6]
first.gen[x, 8] <- temp.data$stats$base_stat[2]
first.gen[x, 9] <- temp.data$stats$base_stat[3]
first.gen[x, 10] <- temp.data$stats$base_stat[1]
}
}
if(!file.exists(data/Pokemon.csv)) {
for(x in nums) {
pokemon.url = paste0(base.url, "pokemon/", x)
print(pokemon.url)
response <- GET(pokemon.url)
body <- content(response, "text", encoding = "UTF-8")
temp.data <- fromJSON(body, flatten = TRUE)
first.gen[x, 1] <- x
first.gen[x, 2] <- temp.data$name
first.gen[x, 3] <- temp.data$types$type.name[1]
first.gen[x, 4] <- temp.data$types$type.name[2]
first.gen[x, 5] <- temp.data$stats$base_stat[5]
first.gen[x, 6] <- temp.data$stats$base_stat[4]
first.gen[x, 7] <- temp.data$stats$base_stat[6]
first.gen[x, 8] <- temp.data$stats$base_stat[2]
first.gen[x, 9] <- temp.data$stats$base_stat[3]
first.gen[x, 10] <- temp.data$stats$base_stat[1]
}
}
if(!file.exists("data/Pokemon.csv")) {
for(x in nums) {
pokemon.url = paste0(base.url, "pokemon/", x)
print(pokemon.url)
response <- GET(pokemon.url)
body <- content(response, "text", encoding = "UTF-8")
temp.data <- fromJSON(body, flatten = TRUE)
first.gen[x, 1] <- x
first.gen[x, 2] <- temp.data$name
first.gen[x, 3] <- temp.data$types$type.name[1]
first.gen[x, 4] <- temp.data$types$type.name[2]
first.gen[x, 5] <- temp.data$stats$base_stat[5]
first.gen[x, 6] <- temp.data$stats$base_stat[4]
first.gen[x, 7] <- temp.data$stats$base_stat[6]
first.gen[x, 8] <- temp.data$stats$base_stat[2]
first.gen[x, 9] <- temp.data$stats$base_stat[3]
first.gen[x, 10] <- temp.data$stats$base_stat[1]
}
}
write.csv(first.gen, file = "Pokemon.csv")
write.csv(first.gen, file = "Pokemon.csv")
write.csv(first.gen, file = "Pokemon.csv")
write.csv(first.gen, file = "data/Pokemon.csv")
write.csv(first.gen, file = "data/Pokemon.csv")
if(!file.exists("data/Pokemon.csv")) {
for(x in nums) {
pokemon.url = paste0(base.url, "pokemon/", x)
print(pokemon.url)
response <- GET(pokemon.url)
body <- content(response, "text", encoding = "UTF-8")
temp.data <- fromJSON(body, flatten = TRUE)
first.gen[x, 1] <- x
first.gen[x, 2] <- temp.data$name
first.gen[x, 3] <- temp.data$types$type.name[1]
first.gen[x, 4] <- temp.data$types$type.name[2]
first.gen[x, 5] <- temp.data$stats$base_stat[5]
first.gen[x, 6] <- temp.data$stats$base_stat[4]
first.gen[x, 7] <- temp.data$stats$base_stat[6]
first.gen[x, 8] <- temp.data$stats$base_stat[2]
first.gen[x, 9] <- temp.data$stats$base_stat[3]
first.gen[x, 10] <- temp.data$stats$base_stat[1]
}
write.csv(first.gen, file = "data/Pokemon.csv")
}
